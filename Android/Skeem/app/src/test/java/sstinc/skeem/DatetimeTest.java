package sstinc.skeem;

import android.database.DatabaseErrorHandler;
import android.icu.text.SymbolTable;
import android.provider.ContactsContract;
import android.provider.Settings;

import org.joda.time.DateTime;
import org.joda.time.chrono.StrictChronology;
import org.junit.Test;
import org.junit.internal.ArrayComparisonFailure;
import org.junit.internal.runners.statements.Fail;

import java.util.Date;
import java.util.Locale;

import static org.junit.Assert.*;

/**
 *  Unit Tests for Datetime Class.
 *  Unit Test for various aspects of the Datetime Class.
 *  Executes on current development host.
 *
 *  @see Test
 */
public class DatetimeTest {
    private Datetime testObject = null;
    private int[][] possibleDatetimeCases = null;
    private String[] possibleDatetimeString = null;


    private void setup()
    {
        this.testObject = new Datetime(org.joda.time.DateTime.now());

        if(this.possibleDatetimeCases == null)
        {
            this.possibleDatetimeCases = generatePossibleDatetime();
        }

        if(this.possibleDatetimeString == null)
        {
            this.possibleDatetimeString = convertStringPossibleDatetime(this.possibleDatetimeCases);
        }

    }

    private void cleanup()
    {

    }

    /**
     * Generates Test Cases for Possible date/time.
     * Generates an multidimensional Array of test cases where the first index refers to the index
     * of the test case, while the second index refers to the unit:
     * 0 - Year
     * 1 - Month of Year
     * 2 - Day of Month
     * 3 - Hour of Day
     * 4 - Minute of Hour
     * Test case generated would be from years 2015-2030.
     * Each possible Minute between those years would be generated.
     *
     * @return Generated Test cases
     */
    private int[][] generatePossibleDatetime()
    {
        final int len = 8269440; //Number of test cases
        int currentIndex = 0;
        int possibleDatetime[][] = new int[len][5];

        //Test years from 2015 - 2030
        for(int year = 2015;year <= 2030;  ++ year)
        {
            //Test months 1 - 12
            for(int month = 1; month <= 12; ++ month)
            {
                //Test days 1 - (28,30,31) depending on month
                int dayLimit = 0;
                if (month == 2) dayLimit = 28;
                else if (month <= 7 && month % 2 == 1) dayLimit = 31;
                else if (month >= 8 && month % 2 == 0) dayLimit = 31;
                else dayLimit = 30;

                for(int day = 1; day <= dayLimit; ++ day)
                {
                    //Test hours 0 - 23
                    for(int hour = 0; hour < 24; ++ hour)
                    {
                        //Test Minute
                        for(int minute = 0; minute < 59; ++ minute)
                        {
                            possibleDatetime[currentIndex][0] = year;
                            possibleDatetime[currentIndex][1] = month;
                            possibleDatetime[currentIndex][2] = day;
                            possibleDatetime[currentIndex][3] = hour;
                            possibleDatetime[currentIndex][4] = minute;

                            currentIndex ++;
                        }
                    }
                }

            }

        }

        return possibleDatetime;
    }

    /**
     * Converts Possible Date/Time Test cases to String
     * Converts Possible Date/Time multidimensional int array generated by
     * <code>generatedPossibleDatetime()</code> to string in the format specified by Datetime class
     *
     * @param possibleDatetime the int Multidimensional Array to convert from
     * @return Coverted String Array
     *
     * @see #generatePossibleDatetime()
     * @see Datetime
     */
    private String[] convertStringPossibleDatetime(int[][] possibleDatetime)
    {
        String[] possibleDatetimeString = new String[possibleDatetime.length];

        for(int index = 0; index < possibleDatetime.length; index ++)
        {
            possibleDatetimeString[index] = String.format(Locale.getDefault(), "%d/%d/%d %d:%d",
                    possibleDatetime[index][0],
                    possibleDatetime[index][1],
                    possibleDatetime[index][2],
                    possibleDatetime[index][3],
                    possibleDatetime[index][4]);
        }

        return possibleDatetimeString;
    }

    @Test
    public void defaultConstructor()
    {
        this.testObject = new Datetime();

        assertTrue((this.testObject != null));
        assertTrue((this.testObject.getHasDate() == false));
        assertTrue((this.testObject.getHasTime() == false));

        cleanup();
    }

    @Test
    public void copyConstructor()
    {
        setup();

        Datetime copyTestObject = new Datetime(this.testObject);
        assertTrue(this.testObject.equals(copyTestObject));

        cleanup();
    }

    @Test
    public void org_joda_time_DateTime_constructor()
    {
        org.joda.time.DateTime testDatetime = org.joda.time.DateTime.now();
        this.testObject = new Datetime(testDatetime);

        assertTrue((this.testObject != null));
        assertTrue((this.testObject.getYear() == testDatetime.getYear()));
        assertTrue((this.testObject.getMonth() == testDatetime.getMonthOfYear()));
        assertTrue((this.testObject.getDay()  == testDatetime.getDayOfMonth()));
        assertTrue((this.testObject.getHour() == testDatetime.getHourOfDay()));
        assertTrue((this.testObject.getMinute() == testDatetime.getMinuteOfHour()));

        cleanup();
    }

    @Test
    public void comparison()
    {
        setup();

        Datetime testCopyObject = new Datetime(this.testObject);
        Datetime anotherTestCopyObject = new Datetime(testCopyObject);

        assertTrue(testCopyObject.equals(this.testObject));
        assertTrue(this.testObject.equals(testCopyObject));
        assertTrue(this.testObject.equals(anotherTestCopyObject));

        cleanup();
    }

    @Test
    public void stringConstructor()
    {
        setup();


        for(int i = 0; i < this.possibleDatetimeCases.length; i ++)
        {
            this.testObject = new Datetime(this.possibleDatetimeString[i]);
            assertTrue(this.testObject != null);

            assertTrue(this.testObject.getYear() == this.possibleDatetimeCases[i][0]);
            assertTrue(this.testObject.getMonth() == this.possibleDatetimeCases[i][1]);
            assertTrue(this.testObject.getDay() == this.possibleDatetimeCases[i][2]);
            assertTrue(this.testObject.getHour() == this.possibleDatetimeCases[i][3]);
            assertTrue(this.testObject.getMinute() == this.possibleDatetimeCases[i][4]);
        }

        cleanup();
    }


    @Test
    public void convertString()
    {
        setup();

        for(String datetimeTestCase : this.possibleDatetimeString)
        {
            this.testObject = new Datetime(datetimeTestCase);
                assertTrue(datetimeTestCase.equals(this.testObject.toString()));
        }

        cleanup();
    }

}
