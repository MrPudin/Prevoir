=======[Request for Comments]======
-----[RFC 1]-----
Date: December 08, 2016
Author: Zhu Zhan Yan

While reading the code for the Android project, I found some questionable
methods lying around in the DateTime class:

DateTime.getMillis() - The class description only mentions that the accuracy if
the data type is only down to the minute however this outputs date/time in
milli-seconds.

DateTime.setHasDate()
DateTime.setHasTime() - These setters set Status Variables (Variables that vary
according to current data). What if someone called on of these methods while
internal datetime did not have time? At Least make them private.

Also the Duration class should not be Deprecated and should at least acts as an
abstraction for the current class used (org.joda.time.Period). 

-----[RFC 2]-----
Date: December 08, 2016
Author: Joel Tio Jin Hon

Do note that Datetime and DateTime are two separate classes. Datetime is
Skeem's implementation of date and time while DateTime is jodatime's
implementation of date and time.

Datetime.getMillis()
The Datetime class's comment for the accuracy of the data type was not fully
updated after I have switched from the deprecated classes to the new jodatime
library. Hence, the description only says the accuracy of the class is down to
a minute. Previously, it was down to a minute due to its smaller use scope.
However, the class has an expanded use scope for calculations of the time as
well. By having accuracy down to milliseconds, division of timeblocks is more
feasible.

Datetime.setHasDate() and Datetime.setHasTime()
These functions have their uses and should not be kept private. They are used
to indicate if date and time values are present in the class. The use case is
when setting date and time values that can be disabled. Instead of removing the
date and time completely, the class continues to store the date and time values
but the flags indicate that they do not exist. For example, when setting a
task's deadline, it has an optional time field. The user sets a time but
changes they're mind and disables it. The flag shows that it does not have time
although it does.

Of course, if you were to just set no date and time but indicate true for the
variables, it will show up Unix Epoch, hence there you need to be careful not
to set these flags wrongly. 

You should note, however, that keeping it private will prove no use either, the
other methods in the class do not rely on these methods to change the flags;
they set the flags directly.

Deprecation of Duration
Providing a layer of abstraction does not prove much use. JodaTime's Period
class provides almost the same functionality as Duration had when it was
implemented. The methods that Duration used to have are also present in
Period. Another thing to note is that JodaTime already has a class called
Duration as well, bringing back the Duration class can cause conflict.

-----[RFC 3]-----
Date: December 10, 2016
Author: Zhu Zhan Yan

Datetime.setHasDate() and Datetime.setHasTime()
Previously, you mentioned that "it has its uses" so I searched for uses of
these methods and found some questionable use cases:
[BEGIN Java Code]
voidblock.getScheduledStart().setHasDate(
    voidblock.getScheduledStart().getHasTime());
voidblock.getScheduledStop().setHasDate(
    voidblock.getScheduledStop().getHasTime());
[END Java Code]
How is having time related to having date?
I am clueless to what this code is supposed to do. Please explain.
[BEGIN Java Code]
// Reset the "from" and "to" date and time values
voidblock.getScheduledStart().setHasDate(false);
voidblock.getScheduledStop().setHasDate(false);
[END Java Code]
This can be replaced with something that makes more sense:
[BEGIN Java Code]
voidblock.setScheduledStart(new Datetime());
voidblock.setScheduledStop(new Datetime());
[END Java Code]
My point is that these variables must reflect the current presence of date or
time in the date time object. Providing this method is an invitation for bugs.

Deprecation of Duration
Providing a layer of abstraction is important to ensuring that the application 
would maintainable if we depend on things we cannot control such as in this
case the JodaTime Library.  What if we wanted to adapt another library? What if
the amended their public interface? Are we going to track down every reference
to library in the entire application? Adding a layer of abstraction ensures
that the references and dependence on the library stays inside a object, such
that in case we want to do the above things, we could do them easily. Personal
experience for depending on a certain library without a layer of abstraction
proved to be a headache when Apple Changed their NSDate,NSString,NSCalendar...
class to Date,String,Calendar... class and shortened most method names.

I can redevelop the duration class and migrate the code base from 
org.joda.time.Period, I just need the go ahead.

I have introduced some refactoring work on the rftr branch, take a look
and use git cherry-pick to introduce the refactoring if good enough.

-----[RFC 4]-----
Date: December 12, 2016
Author: Joel Tio Jin Hon

Datetime.setHasDate() and Datetime.setHasTime()
I will explain further what I mean by its uses. I think a clearer way to name
these methods could be "setDisplayDate" and "setDisplayTime" for the cases you
have brought up. The first example that you raised was in the
VoidblockCreateActivity java file. At that part of the file, it is checking to
see what to do with the new repeated days it has received. There are a few
cases to consider:
    1. The user has not set the date and time but has set a day to repeat
    2. The user has set the date and time and has set a day to repeat
    3. The user has not set the date and time and has not set a day to repeat
    4. The user has set the date and time but has not set a day to repeat
When a repeated day is set, you would want to remove the date if it is set.
If the user removed all the repeated days, you would want to show the date
again.

With that in mind, for the first example use you have given, it falls into case
3 and 4. What it basically is trying to say is "Show back the date if the user
has set something into the start and stop date times previously.". This would
not be possible if the user's previously set date is reset (your second
recommended example), what would happen is it will just give Epoch date which
destroys the safeguards (as the safeguards only check when setting).

For your second example given, it is used to hide the dates but not completely
reset them as I have mentioned above. The reason behind hiding them are, also
as above, to retrieve them when you need to display them again.


Deprecation of Duration
I understand the purpose now, you have my green light. In fact, the more recent
java versions support time better, JodaTime is a library for older java
versions that cannot do time as well. (java.time library actually incorporated
the features from JodaTime)


RFCs
Just to implement a general styling guide, I feel that we should keep to 80
characters maximum and have two newlines between each subject of 
recommendation so that we can have sub-paragraphs.
