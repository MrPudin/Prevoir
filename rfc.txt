=======[Request for Comments]======
-----[RFC 1]-----
Date: December 08, 2016
Author: Zhu Zhan Yan

While reading the code for the Android project, I found some questionable
methods lying around in the DateTime class:

DateTime.getMillis() - The class description only mentions that the accuracy if
the data type is only down to the minute however this outputs date/time in
milli-seconds.

DateTime.setHasDate()
DateTime.setHasTime() - These setters set Status Variables (Variables that vary
according to current data). What if someone called on of these methods while
internal datetime did not have time? At Least make them private.

Also the Duration class should not be Deprecated and should at least acts as an
abstraction for the current class used (org.joda.time.Period). 

-----[RFC 2]-----
Date: December 08, 2016
Author: Joel Tio Jin Hon

Do note that Datetime and DateTime are two separate classes. Datetime is
Skeem's implementation of date and time while DateTime is jodatime's
implementation of date and time.

Datetime.getMillis()
The Datetime class's comment for the accuracy of the data type was not fully
updated after I have switched from the deprecated classes to the new jodatime
library. Hence, the description only says the accuracy of the class is down to
a minute. Previously, it was down to a minute due to its smaller use scope.
However, the class has an expanded use scope for calculations of the time as
well. By having accuracy down to milliseconds, division of timeblocks is more
feasible.

Datetime.setHasDate() and Datetime.setHasTime()
These functions have their uses and should not be kept private. They are used
to indicate if date and time values are present in the class. The use case is
when setting date and time values that can be disabled. Instead of removing the
date and time completely, the class continues to store the date and time values
but the flags indicate that they do not exist. For example, when setting a
task's deadline, it has an optional time field. The user sets a time but
changes they're mind and disables it. The flag shows that it does not have time
although it does.

Of course, if you were to just set no date and time but indicate true for the
variables, it will show up Unix Epoch, hence there you need to be careful not
to set these flags wrongly. 

You should note, however, that keeping it private will prove no use either, the
other methods in the class do not rely on these methods to change the flags;
they set the flags directly.

Deprecation of Duration
Providing a layer of abstraction does not prove much use. JodaTime's Period
class provides almost the same functionality as Duration had when it was
implemented. The methods that Duration used to have are also present in
Period. Another thing to note is that JodaTime already has a class called
Duration as well, bringing back the Duration class can cause conflict.

-----[RFC 3]-----
Date: December 10, 2016
Author: Zhu Zhan Yan

Datetime.setHasDate() and Datetime.setHasTime()
Previously, you mentioned that "it has its uses" so I searched for uses of these 
methods and found some questionable use cases:
[BEGIN Java Code]
voidblock.getScheduledStart().setHasDate(
    voidblock.getScheduledStart().getHasTime());
voidblock.getScheduledStop().setHasDate(
    voidblock.getScheduledStop().getHasTime());
[END Java Code]
How is having time related to having date?
I am clueless to what this code is supposed to do. Please explain.
[BEGIN Java Code]
// Reset the "from" and "to" date and time values
voidblock.getScheduledStart().setHasDate(false);
voidblock.getScheduledStop().setHasDate(false);
[END Java Code]
This can be replaced with something that makes more sense:
[BEGIN Java Code]
voidblock.setScheduledStart(new Datetime());
voidblock.setScheduledStop(new Datetime());
[END Java Code]
My point is that these variables must reflect the current presence of date or
time in the date time object. Providing this method is an invitation for bugs.

Deprecation of Duration
Providing a layer of abstraction is important to ensuring that the application 
would maintainable if we depend on things we cannot control such as in this case
the JodaTime Library.  What if we wanted to adapt another library? What if the 
amended their public interface? Are we going to track down every reference to 
library in the entire application? Adding a layer of abstraction ensures that 
the references and dependence on the library stays inside a object, such that 
in case we want to do the above things, we could do them easily. Personal
experience for depending on a certain library without a layer of abstraction
proved to be a headache when Apple Changed their NSDate,NSString,NSCalendar...
class to Date,String,Calendar... class and shortened most method names.

I can redevelop the duration class and migrate the code base from 
org.joda.time.Period, I just need the go ahead.

I have introduced some refactoring work on the rftr branch, take a look
and use git cherry-pick to introduce the refactoring if good enough.
